# CrackHash: Распределенная система для взлома MD5 хэш-сумм

Проект **CrackHash** представляет собой распределенную систему для взлома MD5 хэш-сумм с использованием подхода brute-force. Система состоит из двух основных компонентов — **менеджера** и **воркеров**, которые взаимодействуют через HTTP и очередь сообщений RabbitMQ.

## Описание системы

### Логика работы

Система работает по следующей логике:

1. **Менеджер** принимает запрос от пользователя, содержащий MD5 хэш слова и максимальную длину слова для перебора.
2. Менеджер генерирует задачи и распределяет их между воркерами, которые будут перебирать слова из алфавита.
3. Каждый **воркер** выполняет перебор слов, вычисляет их хэш и проверяет на совпадение с переданным MD5 хэшем.
4. Когда воркер находит совпадение, он отправляет результат менеджеру.
5. Менеджер обрабатывает все ответы от воркеров и отправляет пользователю результат.

### Задание 1: Реализация сервисов

#### Общее описание

В рамках первой лабораторной работы необходимо было реализовать два приложения:
- **Менеджер**: приложение, которое принимает запросы на взлом хэша и распределяет задачи между воркерами.
- **Воркеры**: приложения, которые выполняют перебор слов и вычисляют хэши.

**Общие требования**:
- Язык программирования: **Java**
- Фреймворк: **Spring Boot**
- Система сборки: **Gradle**
- Развертывание: **Docker Compose**
- Взаимодействие между компонентами осуществляется через **HTTP** (используя **Rest Template**).

#### API менеджера

1. **POST /api/hash/crack**  
   Запрос на взлом хэша:

```json
{
    "hash": "e2fc714c4727ee9395f324cd2e7f331f", 
    "maxLength": 4
}
```
Ответ менеджера: 
```json
{
"requestId": "730a04e6-4de9-41f9-9d5b-53b88b17afac"
}
```
Для генерации слов из алфавита используется библиотека combinatoricslib.


### Задание: Обеспечение отказоустойчивости

#### Общее описание

Во второй части лабораторной работы была улучшена отказоустойчивость системы. Основные изменения включают:

*   **Сохранность данных** при отказе менеджера: все запросы и результаты теперь сохраняются в базе данных MongoDb.
*   **Использование RabbitMQ** для взаимодействия между менеджером и воркерами с использованием очередей.
*   **Репликация базы данных**: MongoDB теперь настроена с репликацией данных.

#### Основные выполненные требования

1.  **Отказоустойчивость менеджера**:

   *   В случае падения менеджера, данные об обрабатываемых запросах сохраняются в базе данных и восстанавливаются после перезапуска.
   *   Менеджер принимает задачи только после успешного сохранения данных в базе и их репликации.
2.  **Отказоустойчивость воркеров**:

   *   Если воркер не отдает ответ, задача передается другому воркеру.
   *   Воркеры масштабируются, и в системе всегда есть минимум два воркера.
3.  **RabbitMQ**:

   *   Используется очередь с **direct exchange** для взаимодействия менеджера и воркеров.
   *   Сообщения теперь персистентны, чтобы не потеряться при рестарте.
   *   Если очереди RabbitMQ недоступны, сообщения сохраняются в базе данных менеджера до восстановления очереди.
4.  **Репликация MongoDB**:

   *   MongoDB настроена с одной **primary** и двумя **secondary** нодами.
   *   Менеджер отвечает клиенту только после успешной репликации данных в базе.

#### Кейсы для проверки

1.  **Стоп сервиса менеджера**:
   *   Все полученные ответы от воркеров сохраняются в базе данных и не теряются.
   *   Ответы на задачи, которые не дошли до менеджера, восстанавливаются при рестарте.
2.  **Стоп primary ноды MongoDB**:

   *   В случае отказа **primary** ноды система продолжает работу без остановки, выбирается новая **primary** нода.
3.  **Стоп RabbitMQ**:

   *   Все необработанные сообщения сохраняются и обрабатываются после восстановления очереди.
4.  **Стоп воркера во время обработки задачи**:

   *   Если воркер падает, задача перенаправляется другому воркеру, чтобы избежать потери данных.

### Структура проекта

1.  **Менеджер**:

   *   Контроллеры для обработки запросов и взаимодействия с воркерами.
   *   Логика распределения задач и получения результатов.
   *   Хранение данных о запросах и их состоянии в базе данных.
2.  **Воркеры**:

   *   Контроллеры для получения задач от менеджера.
   *   Логика перебора слов и вычисления их хэшей.
   *   Отправка результатов обратно в менеджер.
3.  **MongoDB**:

   *   Репликация данных для отказоустойчивости.
   *   Сохранение запросов и результатов с гарантией их восстановления при отказах.
4.  **RabbitMQ**:

   *   Очереди сообщений для взаимодействия между менеджером и воркерами.
   *   Персистентность сообщений и их доставка даже при падении сервисов.
